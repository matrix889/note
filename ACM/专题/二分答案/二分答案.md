[TOC]

### 第k大数

1. 题目大意：
&emsp;&emsp;有A，B两个数组，现在由A和B数组之间的元素互相相乘构成C数组(C的大小是A*B）。问C数组中第k大的数是多少。 

2. 思路:
&emsp;&emsp;两次二分，首先二分最后第k大的数值的大小，判断在C数组中有没有k个比它大的数值；求C数组中比某个数值大，可以先枚举A数组的元素，然后二分B数组。当然，首先需要对A，B两个数组进行排序。

3. SomeThing to remember:
&emsp;&emsp;跪MS三面的原因。。。三面的总监要求的是前100个数值。

4. Code:

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const int MAXN = 11000;

int a[MAXN], b[MAXN], t, n, k;

int solve2(int val, int v){
    int l = 1, r = n + 1;
    while (l < r){
        int m = (l + r) >> 1;

        if (val * b[m] <= v) l = m + 1;
        else r = m;
    }
    return l;
}

int calc(int v){
    int num = 0;
    for (int i = 1; i <= n; ++i)
        num += n - solve2(a[i], v) + 1;
    return num;
}

int solve(){
    int l = 1, r = a[n] * b[n] + 1;
    while (l < r){
        int m = (l + r) >> 1;

        if (calc(m) >= k) l = m + 1;
        else r = m;
    }
    return l;
}

int main(){
    scanf("%d", &t);
    while (t--){
        scanf("%d%d", &n, &k);
        for (int i = 1; i <= n; ++i)
            scanf("%d", &a[i]);
        for (int i = 1; i <= n; ++i)
            scanf("%d", &b[i]);
        sort(a + 1, a + 1 + n);
        sort(b + 1, b + 1 + n);

        //k = n * n - k + 1;
        printf("%d\n", solve());
    }
    return 0;
}

```

5. Link：
[cugb 1220](http://acm.cugb.edu.cn/showproblem.php?problemid=1220)
